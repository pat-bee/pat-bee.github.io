<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>LedgerDB</title>
  <style>
    /* ------------------------------------------------------------------------------------------------------------------ */
    /* CSS: Ledger Styling */
    /* ------------------------------------------------------------------------------------------------------------------ */
    :root {
      /* DAYLIGHT MODE (Default) */
      --c-bg: #ecf0f1;       /* Light Gray/White Background */
      --c-text: #2c3e50;     /* Dark Black/Blue Text */
      --c-border: #bdc3c7;   /* Light Border */
      --c-input-bg: #e0e0e0; /* Light Input Background */
      --c-muted-bg: #f7f7f7; /* Very Light Muted Chip Background */
      --c-modal-bg: rgba(44, 62, 80, 0.9); /* Dark Modal Overlay */
      
      /* DATA COLORS (Kept consistent in both modes) */
      --c-asset: #2ecc71;    /* Bright Green (Positive) */
      --c-debt: #e74c3c;     /* Bright Red (Negative) */
    }

    /* NIGHT MODE (Inverted Palette) */
    .night-mode {
      --c-bg: #1e1e1e;       /* Deep Dark Gray Background */
      --c-text: #ecf0f1;     /* Stark White/Light Text */
      --c-border: #444444;   /* Dark Border */
      --c-input-bg: #333333; /* Dark Input Background */
      --c-muted-bg: #2a2a2a; /* Darker Muted Chip Background */
      --c-modal-bg: rgba(30, 30, 30, 0.95); /* Extremely Dark Modal Overlay */
    }

    body { 
      font-family: 'Courier New', monospace; /* More Brutalist Font */
      margin: 0; 
      background-color: var(--c-bg); 
      color: var(--c-text); 
      transition: background-color 0.5s, color 0.5s; /* Smooth Mode Transition */
    }
    .container { max-width: 900px; margin: 0 auto; padding: 10px; }
    h1 { margin-top: 0; padding-top: 10px; font-size: 1.5em; border-bottom: 2px solid var(--c-text); }

    /* Header Controls */
    .controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: wrap; }
    .modes, .timeframes { display: flex; gap: 5px; margin-right: 10px; }

    /* Radio Buttons (Sharp, boxy style) */
    .radio input { display: none; }
    .radio span { 
      padding: 5px 10px; border: 1px solid var(--c-text); border-radius: 0px; cursor: pointer; font-size: 0.9em; 
      transition: all 0.2s;
    }
    .radio input:checked + span { 
      background-color: var(--c-text); 
      color: var(--c-bg); /* Inverse Text/BG for checked state */
    }
    .radio span:hover { background-color: var(--c-border); }

    /* Totals & Chart */
    .summary { display: flex; justify-content: space-between; margin-bottom: 15px; border: 1px solid var(--c-border); padding: 10px; border-radius: 0px; }
    .summary div { text-align: center; }
    .total-value { font-size: 2em; font-weight: bold; }
    .total-label { font-size: 0.8em; color: var(--c-border); }
    .positive { color: var(--c-asset); }
    .negative { color: var(--c-debt); }
    #chart-container { margin-bottom: 20px; border: 1px solid var(--c-border); padding: 10px; border-radius: 0px; }

    /* Account/Type Chips */
    .chip-list { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px; }
    .chip {
      padding: 8px 12px; border-radius: 0px; font-size: 0.9em; font-weight: bold; cursor: pointer;
      box-shadow: 0 2px 0px rgba(0,0,0,0.5); /* Stark drop shadow */
      color: var(--c-white); 
    }
    .chip.muted {
      background-color: var(--c-muted-bg) !important;
      color: var(--c-text) !important;
      box-shadow: none;
      border: 1px dashed var(--c-border);
    }
    .chip:hover:not(.muted) { opacity: 0.8; transform: translateY(-1px); }
    .chip span { display: block; font-size: 0.7em; font-weight: normal; margin-top: 2px; }

    /* Submission Form & Modal */
    .modal {
      display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%;
      background-color: var(--c-modal-bg); overflow: auto;
    }
    .modal-content {
      background-color: var(--c-bg); margin: 5% auto; padding: 20px; border-radius: 0px;
      width: 90%; max-width: 500px; box-shadow: 0 4px 8px rgba(0,0,0,0.5);
      border: 2px solid var(--c-text); /* Brutal modal border */
    }
    .modal h2 { margin-top: 0; border-bottom: 1px solid var(--c-border); padding-bottom: 10px; }
    .modal-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
    .modal-row label { flex-basis: 40%; }
    .modal-row input, .modal-row select { 
      flex-basis: 55%; padding: 8px; border: 1px solid var(--c-text); border-radius: 0px; 
      background-color: var(--c-input-bg); color: var(--c-text); 
    }
    .submit-btn { 
      padding: 10px 20px; background-color: var(--c-asset); color: var(--c-text); 
      border: 1px solid var(--c-text); border-radius: 0px; cursor: pointer; 
    }
    .close-btn, .add-entry-btn { float: right; font-size: 1.5em; font-weight: bold; cursor: pointer; color: var(--c-text); }
    .close-btn:hover, .add-entry-btn:hover { color: var(--c-debt); }
    .button-group { display: flex; justify-content: space-between; margin-top: 20px; }

    /* Log and Status */
    #status { margin-top: 10px; font-size: 0.9em; }
    #log { margin-top: 10px; font-size: 0.8em; color: var(--c-border); }

    /* Type Toggles Section */
    .type-toggles { margin-bottom: 15px; padding: 10px; border: 1px solid var(--c-border); border-radius: 0px; }
    .toggle-item { display: inline-flex; align-items: center; margin-right: 15px; cursor: pointer; font-size: 0.9em; }
    .toggle-item input[type="checkbox"] { margin-right: 5px; }

    /* See All Button (Brutalist Style) */
    #unmute-all-btn { 
      background-color: #3498db; /* Keep the distinct blue/cyan */
      margin-left: 10px;
      padding: 5px 10px;
      border-radius: 0px;
      font-size: 0.9em;
      font-weight: normal;
      cursor: pointer;
      color: var(--c-text); /* Use main text color for contrast */
      border: 1px solid var(--c-text);
    }
    .night-mode #unmute-all-btn { 
       background-color: #0088AA; /* Sharper Cyan for night */
    }
    #unmute-all-btn:hover { opacity: 0.8; }
    
    /* Type Toggle Brutalist Checkbox (Monochrome) */
    .toggle-item input[type="checkbox"] {
      /* Hide the default checkbox */
      appearance: none;
      -webkit-appearance: none;
      margin: 0 5px 0 0;
      padding: 0;
      display: inline-block;
      cursor: pointer;
      
      /* Define the outer block/container */
      position: relative;
      width: 16px; 
      height: 16px;
      background-color: var(--c-bg); 
      border: 2px solid var(--c-text); /* Heavy border using main text color */
      box-sizing: border-box;
      vertical-align: middle;
      transition: none; 
    }

    /* Checked State: Solid inner square */
    .toggle-item input[type="checkbox"]:checked::before {
      content: '';
      display: block;
      position: absolute;
      top: 2px;
      left: 2px;
      width: 8px; 
      height: 8px;
      background-color: var(--c-text); /* Fills with main text color */
      transform: scale(1);
      transition: none;
    }
    
    /* Hide label text when toggling */
    .toggle-item label span.visually-hidden {
        position: absolute;
        width: 1px;
        height: 1px;
        margin: -1px;
        padding: 0;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        border: 0;
    }
  </style>
</head>
<body>

  <div class="container">
    <h1>LedgerDB Financial Snapshot</h1>

    <div class="controls">
      <div style="display: flex; align-items: center;">
        <div class="modes">
          <label class="radio">
            <input type="radio" name="mode" value="totals" checked />
            <span>Totals</span>
          </label>
          <label class="radio">
            <input type="radio" name="mode" value="peraccount" />
            <span>Per-Account</span>
          </label>
          <label class="radio">
            <input type="radio" name="mode" value="pertype" />
            <span>Per-Type</span>
          </label>
        </div>
        <div id="unmute-all-btn" class="chip">See All</div>
      </div>

      <div class="timeframes">
        <label class="radio">
          <input type="radio" name="timeframe" value="today" />
          <span>Today</span>
        </label>
        <label class="radio">
          <input type="radio" name="timeframe" value="7d" />
          <span>7D</span>
        </label>
        <label class="radio">
          <input type="radio" name="timeframe" value="30d" />
          <span>30D</span>
        </label>
        <label class="radio">
          <input type="radio" name="timeframe" value="ytd" checked />
          <span>YTD</span>
        </label>
        <label class="radio">
          <input type="radio" name="timeframe" value="1y" />
          <span>1Y</span>
        </label>
        <label class="radio">
          <input type="radio" name="timeframe" value="all" />
          <span>ALL</span>
        </label>
      </div>
    </div>

    <div id="type-toggles-container" class="type-toggles" style="display: none;">
      <p style="margin-top: 0; font-weight: bold;">Filter by Type (Toggle to Mute):</p>
      <div id="type-toggles" style="display: flex; flex-wrap: wrap; gap: 10px;">
        </div>
    </div>
    
    <div id="status">Loading data...</div>

    <div class="summary">
      <div>
        <div id="net-worth" class="total-value positive">$0.00</div>
        <div class="total-label">Net Worth</div>
      </div>
      <div>
        <div id="total-assets" class="total-value positive">$0.00</div>
        <div class="total-label">Total Assets</div>
      </div>
      <div>
        <div id="total-debts" class="total-value negative">$0.00</div>
        <div class="total-label">Total Debts</div>
      </div>
    </div>

    <div id="chart-container">
      <div id="chart" style="width: 100%; height: 300px;"></div>
    </div>

    <div id="account-list" class="chip-list">
      </div>
    
    <button class="submit-btn" onclick="document.getElementById('modal').style.display='block'">+ Add Entry</button>

    <div id="log"></div>

    <div id="modal" class="modal">
      <div class="modal-content">
        <span class="close-btn" onclick="document.getElementById('modal').style.display='none'">&times;</span>
        <h2>Add New Entry</h2>
        
        <form id="submission-form">
          <div id="entry-fields">
            <div class="modal-row">
              <label for="account-select-0">Account:</label>
              <select id="account-select-0" required style="flex-basis: 55%; padding: 8px; border: 1px solid var(--c-text); border-radius: 0px; background-color: var(--c-input-bg); color: var(--c-text);"></select>
            </div>
            <div class="modal-row">
              <label for="value-input-0">Value:</label>
              <input type="number" id="value-input-0" step="0.01" required placeholder="0.00">
            </div>
          </div>
          
          <div style="text-align: right;">
            <button type="button" class="add-entry-btn" onclick="addEntryField()">+ Add Account</button>
          </div>
          
          <div class="button-group">
            <button type="submit" class="submit-btn">Submit Values</button>
          </div>
        </form>
      </div>
    </div>
  </div>

<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
<script>
  /* ------------------------------------------------------------------------------------------------------------------ */
  /* JAVASCRIPT: Ledger Logic */
  /* ------------------------------------------------------------------------------------------------------------------ */

  // Replace with your deployed Apps Script URL GEMINI
  const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbzWd8KkkoQf6eqXOpC42TRGeByhmY2d4s6ag4KH7iUDPt6txr5pu41E0F7qar6kVjSmWg/exec';
const API_BASE = 'https://script.google.com/macros/s/AKfycbzWd8KkkoQf6eqXOpC42TRGeByhmY2d4s6ag4KH7iUDPt6txr5pu41E0F7qar6kVjSmWg/exec';
const SHEET_ID = '1v5Xc57U77arzf-JUqe85Iwwh-9Z1i1u0Rcmyrans9o8/edit?usp=sharing';
  // Global state variables
  let ACCOUNTS = [];
  let HISTORY = {};
  let SUMMARY = {};
  let TIMEFRAME = 'ytd';
  let MODE = 'totals'; 
  let CHART = null;
  let LOCALE_FORMATTER = null;
  
  let MUTED_ACCOUNTS = new Set();
  let MUTED_TYPES = new Set();
  let TYPES_MAP = new Map();

  // --- DAY/NIGHT MODE LOGIC (NEW) ---
  function applyNightMode() {
      const now = new Date();
      const hour = now.getHours();
      // Night mode is active between 7 PM (19:00) and 6 AM (06:00)
      if (hour >= 19 || hour < 6) {
          document.body.classList.add('night-mode');
      } else {
          document.body.classList.remove('night-mode');
      }
      // Re-draw chart on mode change to refresh Google Charts background color
      if (CHART) renderChart();
  }
  // --- END DAY/NIGHT MODE LOGIC ---

  google.charts.load('current', { 'packages': ['corechart'] });
  google.charts.setOnLoadCallback(initialize);

  function initialize() {
    // Apply initial Day/Night mode setting
    applyNightMode();
    
    CHART = new google.visualization.LineChart(document.getElementById('chart'));
    LOCALE_FORMATTER = new Intl.NumberFormat(undefined, { style: 'currency', currency: 'USD' });
    
    // Set up listeners for timeframe and mode
    document.querySelectorAll('input[name="timeframe"]').forEach(r => {
      r.addEventListener('change', (e) => { TIMEFRAME = e.target.value; fetchSnapshot(); });
      if (r.checked) TIMEFRAME = r.value;
    });

    document.querySelectorAll('input[name="mode"]').forEach(r => {
      r.addEventListener('change', (e) => { 
          MODE = e.target.value; 
          MUTED_ACCOUNTS.clear();
          MUTED_TYPES.clear();
          document.getElementById('type-toggles-container').style.display = (MODE === 'pertype' ? 'block' : 'none');
          renderChart();
          renderAccounts(); 
      });
      if (r.checked) MODE = r.value;
    });
    
    document.getElementById('unmute-all-btn').addEventListener('click', unmuteAll);

    fetchSnapshot();
  }
  
  function unmuteAll() {
    MUTED_ACCOUNTS.clear();
    MUTED_TYPES.clear();
    document.querySelectorAll('#type-toggles input[type="checkbox"]').forEach(cb => cb.checked = false);
    renderChart();
    renderAccounts();
  }

  function getAggregatedHistoryByType(filteredAccounts) {
      const historyByType = new Map();
      const typeCodes = new Set(filteredAccounts.map(a => a.type).filter(t => t));

      for (const acct of filteredAccounts) {
          const monthlySeries = HISTORY.series[acct.name]?.monthly;
          if (!monthlySeries || !acct.type || !TYPES_MAP.has(acct.type)) continue;

          monthlySeries.forEach((value, idx) => {
              const timestamp = HISTORY.dateAxis[idx]; 
              const typeHistory = historyByType.get(acct.type) || new Map();
              
              const currentValue = typeHistory.get(timestamp) || 0;
              typeHistory.set(timestamp, currentValue + value);
              historyByType.set(acct.type, typeHistory);
          });
      }

      const sortedTypeCodes = Array.from(typeCodes).sort();
      const header = ['Date'].concat(sortedTypeCodes.map(code => TYPES_MAP.get(code).label));
      const chartData = [header];
      
      const lastValue = {};
      for (const timestamp of HISTORY.dateAxis) {
          const row = [timestamp];
          
          for (const typeCode of sortedTypeCodes) {
              const typeHistory = historyByType.get(typeCode);
              const value = typeHistory ? typeHistory.get(timestamp) : undefined;
              
              const valueToUse = (value !== undefined) ? value : lastValue[typeCode] || null;
              row.push(valueToUse);
              if (value !== undefined) {
                  lastValue[typeCode] = value;
              }
          }
          chartData.push(row);
      }

      return { chartData, sortedTypeCodes };
  }

  function renderTypeToggles() {
    const toggleContainer = document.getElementById('type-toggles');
    toggleContainer.innerHTML = '';

    const uniqueTypes = new Map();
    ACCOUNTS.forEach(a => {
        if (TYPES_MAP.has(a.type)) {
            uniqueTypes.set(a.type, TYPES_MAP.get(a.type).label);
        }
    });

    Array.from(uniqueTypes.keys()).sort().forEach(code => {
        const label = uniqueTypes.get(code);
        const isMuted = MUTED_TYPES.has(code);
        const color = TYPES_MAP.get(code).color;

        const toggleItem = document.createElement('label');
        toggleItem.classList.add('toggle-item');
        toggleItem.innerHTML = `
            <input type="checkbox" id="toggle-${code}" data-type-code="${code}" ${isMuted ? 'checked' : ''}>
            <span style="color: ${color};">${label}</span>
        `;
        
        toggleItem.querySelector('input').addEventListener('change', (e) => {
            if (e.target.checked) {
                MUTED_TYPES.add(code);
            } else {
                MUTED_TYPES.delete(code);
            }
            renderChart();
            renderAccounts();
        });

        toggleContainer.appendChild(toggleItem);
    });
  }

  function fetchSnapshot() {
    document.getElementById('status').textContent = 'Loading data...';
    document.getElementById('log').textContent = '';

    const url = SCRIPT_URL + `?route=snapshot&timeframe=${TIMEFRAME}`;
    fetch(url)
      .then(response => response.json())
      .then(data => {
        if (!data.ok) {
          throw new Error(data.error || 'Unknown API error');
        }
        
        ACCOUNTS = data.accounts;
        HISTORY = data;
        SUMMARY = data.totals;

        TYPES_MAP.clear();
        data.types.forEach(t => TYPES_MAP.set(t.code, { label: t.label, color: t.color }));

        document.getElementById('status').textContent = `Data as of ${data.as_of}.`;
        
        renderChart();
        renderAccounts();
        
        renderTypeToggles();
        document.getElementById('type-toggles-container').style.display = (MODE === 'pertype' ? 'block' : 'none');

        const select = document.getElementById('account-select-0');
        select.innerHTML = ACCOUNTS.map(a => `<option value="${a.name}">${a.name}</option>`).join('');
        
      })
      .catch(err => {
        document.getElementById('status').textContent = 'Error fetching data: ' + err.message;
        document.getElementById('log').textContent = '';
        console.error('Fetch Error:', err);
      });
  }

  function renderChart() {
    if (!CHART || !HISTORY.dateAxis || ACCOUNTS.length === 0) return;

    let filteredAccounts = ACCOUNTS;
    if (MODE === 'peraccount' || MODE === 'totals') {
        filteredAccounts = ACCOUNTS.filter(a => !MUTED_ACCOUNTS.has(a.name));
    } else if (MODE === 'pertype') {
        filteredAccounts = ACCOUNTS.filter(a => !MUTED_TYPES.has(a.type));
    }

    let chartData = [];
    const isNightMode = document.body.classList.contains('night-mode');
    
    // Get CSS variables in real-time
    const style = getComputedStyle(document.body);
    const text_color = style.getPropertyValue('--c-text').trim();
    const bg_color = style.getPropertyValue('--c-bg').trim();
    
    let options = {
      title: 'Net Worth History',
      legend: { position: 'bottom', textStyle: { color: text_color } },
      hAxis: { title: 'Date', textStyle: { color: text_color }, titleTextStyle: { color: text_color } },
      vAxis: { title: 'Value', format: LOCALE_FORMATTER.format(0).replace('0', ''), textStyle: { color: text_color }, titleTextStyle: { color: text_color } },
      series: {},
      backgroundColor: { fill: bg_color }, // Dynamic background
      chartArea: { backgroundColor: { fill: bg_color } },
      titleTextStyle: { color: text_color }
    };

    if (MODE === 'totals') {
      const totalSeries = HISTORY.totals.assets.map((v, i) => v + HISTORY.totals.debts[i]);
      chartData.push(['Date', 'Net Worth']);
      totalSeries.forEach((v, i) => {
        chartData.push([HISTORY.dateAxis[i], v]);
      });
      options.series[0] = { color: text_color }; // Use text color for total line

    } else if (MODE === 'peraccount') {
      const header = ['Date'].concat(filteredAccounts.map(a => a.name));
      chartData.push(header);
      
      filteredAccounts.forEach((a, seriesIdx) => {
        options.series[seriesIdx] = { color: a.color || (a.kind === 'asset' ? style.getPropertyValue('--c-asset') : style.getPropertyValue('--c-debt')) };
        const monthlySeries = HISTORY.series[a.name]?.monthly || [];
        a.monthlySeries = monthlySeries; 
      });

      HISTORY.dateAxis.forEach((d, i) => {
        const row = [d].concat(filteredAccounts.map(a => a.monthlySeries[i]));
        chartData.push(row);
      });
      options.title = 'Account History';

    } else if (MODE === 'pertype') {
        const { chartData: typeChartData, sortedTypeCodes } = getAggregatedHistoryByType(filteredAccounts);
        chartData = typeChartData;

        options.series = sortedTypeCodes.reduce((acc, code, index) => {
            acc[index] = { color: TYPES_MAP.get(code)?.color || text_color };
            return acc;
        }, {});
        options.title = 'Type History (Aggregated)';
    }

    try {
      if (chartData.length > 1) {
        const dataTable = google.visualization.arrayToDataTable(chartData);
        CHART.draw(dataTable, options);
      } else {
        document.getElementById('chart').innerHTML = 'No data to display.';
      }
    } catch (e) {
        document.getElementById('chart').innerHTML = 'Error rendering chart. Check console for details.';
        console.error('Chart Error:', e);
    }
    
    renderSummary(filteredAccounts);
  }

  function renderSummary(filteredAccounts) {
    const totalAssets = filteredAccounts.filter(a => a.kind === 'asset').reduce((sum, a) => sum + (a.last || 0), 0);
    const totalDebts = filteredAccounts.filter(a => a.kind === 'debt').reduce((sum, a) => sum + (a.last || 0), 0);
    const netWorth = totalAssets + totalDebts;

    document.getElementById('net-worth').textContent = LOCALE_FORMATTER.format(netWorth);
    document.getElementById('net-worth').className = 'total-value ' + (netWorth >= 0 ? 'positive' : 'negative');

    document.getElementById('total-assets').textContent = LOCALE_FORMATTER.format(totalAssets);
    document.getElementById('total-assets').className = 'total-value positive';

    document.getElementById('total-debts').textContent = LOCALE_FORMATTER.format(totalDebts);
    document.getElementById('total-debts').className = 'total-value negative';
  }

  function renderAccounts() {
    const accountListEl = document.getElementById('account-list');
    accountListEl.innerHTML = '';

    const style = getComputedStyle(document.body);
    const default_asset_color = style.getPropertyValue('--c-asset').trim();
    const default_debt_color = style.getPropertyValue('--c-debt').trim();


    if (MODE === 'pertype') {
      const types = new Map();

      ACCOUNTS.forEach(acct => {
          const typeCode = acct.type;
          if (!typeCode || !TYPES_MAP.has(typeCode)) return;

          const latestValue = acct.last || 0; 
          const typeInfo = TYPES_MAP.get(typeCode);

          const info = types.get(typeCode) || {
              code: typeCode,
              label: typeInfo.label,
              color: typeInfo.color,
              value: 0,
          };
          info.value += latestValue;
          types.set(typeCode, info);
      });
      
      Array.from(types.values()).sort((a, b) => b.value - a.value).forEach(typeInfo => {
          const isMuted = MUTED_TYPES.has(typeInfo.code);
          
          const chip = document.createElement('div');
          chip.dataset.code = typeInfo.code;
          chip.classList.add('chip');
          if (isMuted) chip.classList.add('muted');
          
          chip.style.backgroundColor = isMuted ? 'var(--c-muted-bg)' : typeInfo.color;
          chip.style.color = isMuted ? 'var(--c-text)' : 'var(--c-bg)';

          const fmtValue = LOCALE_FORMATTER.format(typeInfo.value);
          chip.innerHTML = `<strong>${typeInfo.label}</strong><span>${fmtValue}</span>`;

          chip.addEventListener('click', () => {
              if (MUTED_TYPES.has(typeInfo.code)) {
                  MUTED_TYPES.delete(typeInfo.code);
                  const toggle = document.getElementById(`toggle-${typeInfo.code}`);
                  if (toggle) toggle.checked = false;
              } else {
                  MUTED_TYPES.add(typeInfo.code);
                  const toggle = document.getElementById(`toggle-${typeInfo.code}`);
                  if (toggle) toggle.checked = true;
              }
              renderChart();
              renderAccounts();
          });
          accountListEl.appendChild(chip);
      });
      
    } else {
        // Existing per-account rendering logic
        ACCOUNTS.sort((a, b) => a.kind === 'debt' ? 1 : -1).forEach(acct => {
            const isMuted = MUTED_ACCOUNTS.has(acct.name);
            const chip = document.createElement('div');
            chip.dataset.name = acct.name;
            chip.classList.add('chip');
            if (isMuted) chip.classList.add('muted');
            
            const color = acct.color || (acct.kind === 'asset' ? default_asset_color : default_debt_color);
            chip.style.backgroundColor = isMuted ? 'var(--c-muted-bg)' : color;
            chip.style.color = isMuted ? 'var(--c-text)' : 'var(--c-bg)';

            const fmtValue = LOCALE_FORMATTER.format(acct.last || 0);
            chip.innerHTML = `<strong>${acct.name}</strong><span>${fmtValue}</span>`;

            chip.addEventListener('click', () => {
                if (MUTED_ACCOUNTS.has(acct.name)) {
                    MUTED_ACCOUNTS.delete(acct.name);
                } else {
                    MUTED_ACCOUNTS.add(acct.name);
                }
                renderChart();
                renderAccounts();
            });
            accountListEl.appendChild(chip);
        });
    }
  }

  // --- Submission Form Logic (Unchanged) ---
  function addEntryField() {
    const entryFields = document.getElementById('entry-fields');
    const index = entryFields.children.length / 2;
    
    const accountRow = document.createElement('div');
    accountRow.classList.add('modal-row');
    accountRow.innerHTML = `
      <label for="account-select-${index}">Account:</label>
      <select id="account-select-${index}" required style="flex-basis: 55%; padding: 8px; border: 1px solid var(--c-text); border-radius: 0px; background-color: var(--c-input-bg); color: var(--c-text);">${ACCOUNTS.map(a => `<option value="${a.name}">${a.name}</option>`).join('')}</select>
    `;
    entryFields.appendChild(accountRow);
    
    const valueRow = document.createElement('div');
    valueRow.classList.add('modal-row');
    valueRow.innerHTML = `
      <label for="value-input-${index}">Value:</label>
      <input type="number" id="value-input-${index}" step="0.01" required placeholder="0.00">
    `;
    entryFields.appendChild(valueRow);
  }

  document.getElementById('submission-form').addEventListener('submit', (e) => {
    e.preventDefault();
    document.getElementById('status').textContent = 'Submitting entries...';
    document.getElementById('log').textContent = '';

    const entries = [];
    const entryFields = document.getElementById('entry-fields');
    const numEntries = entryFields.children.length / 2;

    for (let i = 0; i < numEntries; i++) {
        const account = document.getElementById(`account-select-${i}`).value;
        const value = document.getElementById(`value-input-${i}`).value;

        if (account && value !== '') {
            entries.push({ account, value: parseFloat(value) });
        }
    }

    if (entries.length === 0) {
        document.getElementById('status').textContent = 'Error: No valid entries to submit.';
        return;
    }

    fetch(SCRIPT_URL + '?route=submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ entries })
    })
    .then(response => response.json())
    .then(data => {
        if (data.ok) {
            document.getElementById('status').textContent = `Submission successful. Updated: ${data.updated}, Copied: ${data.copied_forward}.`;
            document.getElementById('modal').style.display = 'none';
            // Reset form fields
            document.getElementById('submission-form').reset();
            // Refetch data to update chart
            fetchSnapshot();
        } else {
            document.getElementById('status').textContent = 'Submission failed: ' + (data.error || 'Unknown error');
        }
        document.getElementById('log').textContent = JSON.stringify(data);
    })
    .catch(err => {
        document.getElementById('status').textContent = 'Network error during submission: ' + err.message;
        console.error('Submission Error:', err);
    });
  });
  
  window.onclick = function(event) {
    const modal = document.getElementById('modal');
    if (event.target == modal) {
      modal.style.display = "none";
    }
  }
</script>

</body>
</html>
const API_BASE = 'https://script.google.com/macros/s/AKfycbzWd8KkkoQf6eqXOpC42TRGeByhmY2d4s6ag4KH7iUDPt6txr5pu41E0F7qar6kVjSmWg/exec';
const SHEET_ID = '1v5Xc57U77arzf-JUqe85Iwwh-9Z1i1u0Rcmyrans9o8/edit?usp=sharing';

const API_BASE = 'https://script.google.com/macros/s/AKfycbzWd8KkkoQf6eqXOpC42TRGeByhmY2d4s6ag4KH7iUDPt6txr5pu41E0F7qar6kVjSmWg/exec';
const SHEET_ID = '1v5Xc57U77arzf-JUqe85Iwwh-9Z1i1u0Rcmyrans9o8/edit?usp=sharing';

    
    
  /* ============================================
    THEME (DAY / NIGHT)
    ============================================ */

// Apply theme to <html> and keep UI in sync
function setTheme(theme) {
  const root = document.documentElement;
  const normalized = theme === 'dark' ? 'dark' : 'light';

  root.setAttribute('data-theme', normalized);

  // Persist preference if possible
  try {
    localStorage.setItem('ledgerTheme', normalized);
  } catch (e) {
    // ignore storage errors (private mode, etc.)
  }

  // Update tiny toolbar button
  const btn = document.getElementById('theme-toggle-btn');
  if (btn) {
    if (normalized === 'dark') {
      btn.textContent = '☀︎';
      btn.title = 'Switch to light mode';
      btn.setAttribute('aria-label', 'Switch to light mode');
    } else {
      btn.textContent = '☾';
      btn.title = 'Switch to dark mode';
      btn.setAttribute('aria-label', 'Switch to dark mode');
    }
  }
}

// Decide initial theme from user preference or local time
function initTheme() {
  let theme = 'light';

  try {
    const stored = localStorage.getItem('ledgerTheme');
    if (stored === 'light' || stored === 'dark') {
      theme = stored;
    } else {
      const hour = new Date().getHours(); // browser local time
      // Day: 7am–7pm → light, otherwise dark
      theme = (hour >= 7 && hour < 19) ? 'light' : 'dark';
    }
  } catch (e) {
    const hour = new Date().getHours();
    theme = (hour >= 7 && hour < 19) ? 'light' : 'dark';
  }

  setTheme(theme);
}

function toggleTheme() {
  const current =
    document.documentElement.getAttribute('data-theme') || 'light';
  setTheme(current === 'dark' ? 'light' : 'dark');
}
  
    
    
    
    
    
    
/* ============================================
    
    APPLICATION STATE
   ============================================ */
let SNAP = null;
let MODE = 'totals';
let TIMEFRAME = 'ytd';
let IS_LOADING = false;
let TOAST_TIMER = null;
let LONG_PRESS_TIMER = null;
const LONG_PRESS_DURATION = 500;

let MUTED_ACCOUNTS = new Set();
let MUTED_TYPES = new Set();

const TYPE_LABELS = {
  'bk': 'Banks',
  'cc': 'CreditCards',
  'bill': 'Bills',
  'ii': 'Investments',
  'sv': 'Savings'
};

let ACCOUNT_METADATA = new Map();  // accountName -> { limit, color, link }
let TYPE_META_OVERRIDES = new Map(); // typeCode -> { color }

/* ============================================
    UI UTILITIES
   ============================================ */
function showToast(msg, type = 'info', duration = 3000) {
  const el = document.getElementById('toast');
  if (!el) return;

  if (TOAST_TIMER) clearTimeout(TOAST_TIMER);

  el.textContent = msg;
  el.dataset.type = type;
  el.classList.add('show');

  TOAST_TIMER = setTimeout(() => el.classList.remove('show'), duration);
}

function setLoading(loading, message) {
  IS_LOADING = loading;

  document.getElementById('refresh').disabled = loading;
  document.getElementById('submitAll').disabled = loading;

  document.querySelectorAll('.row .left input[type="number"]').forEach(inp => {
    inp.disabled = loading;
    inp.classList.toggle('submitting', loading);
  });

  if (message && !document.getElementById('delete-modal-backdrop').classList.contains('show')) {
    showToast(message, 'info', loading ? 10000 : 3000);
  }
}

/* ============================================
    DELETE MODAL
   ============================================ */
function showDeleteConfirm(account, date, value, readableValue) {
  if (IS_LOADING) return;

  const backdrop = document.getElementById('delete-modal-backdrop');
  const modal = document.getElementById('delete-modal');
  const details = document.getElementById('delete-modal-details');
  const confirmBtn = document.getElementById('delete-btn-confirm');

  details.textContent = `${account}: ${readableValue} on ${date}`;

  backdrop.classList.add('show');
  modal.classList.add('show');

  confirmBtn.onclick = () => processDelete(account, date, value);
}

function hideDeleteConfirm() {
  document.getElementById('delete-modal-backdrop').classList.remove('show');
  document.getElementById('delete-modal').classList.remove('show');
}

async function processDelete(account, date, value) {
  hideDeleteConfirm();
  if (IS_LOADING) return;
  setLoading(true, 'Deleting entry…');

  try {
    const body = new URLSearchParams({ 
      payload: JSON.stringify({ account, date, value: Number(value) }) 
    });

    const res = await fetch(`${API_BASE}?route=delete`, { method: 'POST', body });
    const text = await res.text();

    let j;
    try { 
      j = JSON.parse(text); 
    } catch {
      console.error('Delete non-JSON:', text);
      showToast('Delete failed (non-JSON response)', 'error', 5000);
      setLoading(false);
      return;
    }

    if (!j.ok) {
      console.error('Delete JSON error:', j);
      showToast(`Delete failed: ${j.error || 'Unknown'}`, 'error', 5000);
      setLoading(false);
      return;
    }

    showToast('Entry deleted. Refreshing…', 'success');
    await fetchSnapshot();

  } catch (e) {
    console.error(e);
    setLoading(false);
    showToast('Network error deleting entry.', 'error', 5000);
  }
}

/* ============================================
    EDIT CHIP MODAL
   ============================================ */
function showEditChipModal(account, date, value, readableValue) {
  if (IS_LOADING) return;

  const backdrop = document.getElementById('edit-chip-modal-backdrop');
  const modal = document.getElementById('edit-chip-modal');
  const details = document.getElementById('edit-chip-details');
  const valueInput = document.getElementById('edit-chip-value');
  const dateInput = document.getElementById('edit-chip-date');
  const saveBtn = document.getElementById('edit-chip-save');
  const deleteBtn = document.getElementById('edit-chip-delete');

  details.textContent = `Account: ${account}`;
  valueInput.value = Number(value);

  const dateParts = date.split('/');
  if (dateParts.length === 3) {
    const [month, day, year] = dateParts;
    dateInput.value = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
  } else {
    dateInput.value = '';
  }

  backdrop.classList.add('show');
  modal.classList.add('show');

  setTimeout(() => valueInput.focus(), 100);

  saveBtn.onclick = () => processEditChip(account, date, value);
  deleteBtn.onclick = () => {
    hideEditChipModal();
    showDeleteConfirm(account, date, value, readableValue);
  };
}

function hideEditChipModal() {
  document.getElementById('edit-chip-modal-backdrop').classList.remove('show');
  document.getElementById('edit-chip-modal').classList.remove('show');
}

async function processEditChip(originalAccount, originalDate, originalValue) {
  if (IS_LOADING) return;

  const valueInput = document.getElementById('edit-chip-value');
  const dateInput = document.getElementById('edit-chip-date');

  const newValue = Number(valueInput.value);
  const newDateISO = dateInput.value;

  if (isNaN(newValue) || newValue === 0) {
    showToast('Please enter a valid non-zero value', 'error');
    return;
  }

  if (!newDateISO) {
    showToast('Please select a date', 'error');
    return;
  }

  const [year, month, day] = newDateISO.split('-');
  const newDate = `${parseInt(month)}/${parseInt(day)}/${year}`;

  hideEditChipModal();
  setLoading(true, 'Updating entry…');

  try {
    const deleteBody = new URLSearchParams({ 
      payload: JSON.stringify({ 
        account: originalAccount, 
        date: originalDate, 
        value: Number(originalValue) 
      }) 
    });

    const deleteRes = await fetch(`${API_BASE}?route=delete`, { method: 'POST', body: deleteBody });
    const deleteText = await deleteRes.text();
    const deleteJson = JSON.parse(deleteText);

    if (!deleteJson.ok) {
      throw new Error('Delete failed: ' + (deleteJson.error || 'Unknown'));
    }

    const submitBody = new URLSearchParams({ 
      payload: JSON.stringify({ 
        entries: [{ 
          account: originalAccount, 
          value: newValue,
          date: newDate
        }] 
      }) 
    });

    const submitRes = await fetch(`${API_BASE}?route=submit`, { method: 'POST', body: submitBody });
    const submitText = await submitRes.text();
    const submitJson = JSON.parse(submitText);

    if (!submitJson.ok) {
      throw new Error('Submit failed: ' + (submitJson.error || 'Unknown'));
    }

    showToast('Entry updated! Refreshing…', 'success');
    await fetchSnapshot();

  } catch (e) {
    console.error('Edit error:', e);
    setLoading(false);
    showToast('Failed to update entry: ' + e.message, 'error', 5000);
  }
}

/* ============================================
    ACCOUNT MENU MODAL
   ============================================ */
function showAccountMenu(accountName) {
  if (IS_LOADING) return;

  const backdrop = document.getElementById('account-menu-modal-backdrop');
  const modal = document.getElementById('account-menu-modal');
  const accountNameEl = document.getElementById('account-menu-account-name');
  const deleteBtn = document.getElementById('account-menu-delete');
  const addBtn = document.getElementById('account-menu-add');
  const editBtn = document.getElementById('account-menu-edit');

  accountNameEl.textContent = accountName;

  backdrop.classList.add('show');
  modal.classList.add('show');

  editBtn.onclick = () => {
    hideAccountMenu();
    showEditAccountModal(accountName);
  };

  deleteBtn.onclick = () => {
    hideAccountMenu();
    showToast('Account deletion coming in a future version.', 'info', 3000);
  };

  addBtn.onclick = () => {
    hideAccountMenu();
    showToast('Add account feature coming in a future version.', 'info', 3000);
  };
}

function hideAccountMenu() {
  document.getElementById('account-menu-modal-backdrop').classList.remove('show');
  document.getElementById('account-menu-modal').classList.remove('show');
}

/* ============================================
    EDIT ACCOUNT MODAL
   ============================================ */
function normalizeHexColor(value) {
  if (!value) return null;
  let v = value.trim();
  if (!v) return null;
  if (v[0] !== '#') v = '#' + v;
  if (!/^#[0-9A-Fa-f]{6}$/.test(v)) return null;
  return v.toUpperCase();
}

function showEditAccountModal(accountName) {
  if (IS_LOADING) return;

  const backdrop   = document.getElementById('edit-account-modal-backdrop');
  const modal      = document.getElementById('edit-account-modal');
  const nameEl     = document.getElementById('edit-account-name');
  const typeSelect = document.getElementById('edit-account-type');
  const limitInput = document.getElementById('edit-account-limit');
  const aprInput   = document.getElementById('edit-account-apr');
  const valueInput = document.getElementById('edit-account-value');
  const colorInput = document.getElementById('edit-account-color');
  const colorPicker = document.getElementById('edit-account-color-picker');
  const linkInput  = document.getElementById('edit-account-link');
  const saveBtn    = document.getElementById('edit-account-save');

  nameEl.textContent = accountName;

  const account = SNAP?.accounts?.find(a => a.name === accountName);
  if (!account) {
    showToast('Account not found', 'error');
    return;
  }

  const metadata = ACCOUNT_METADATA.get(accountName) || {};

  typeSelect.value = account.type || 'bk';
  limitInput.value = metadata.limit || '';
  aprInput.value   = account.apr || 0;

  const series = SNAP?.series?.[accountName];
  const currentValue = series?.last ?? 0;
  valueInput.value = currentValue;

  const effectiveColor = metadata.color || account.color || '';
  const normalized = normalizeHexColor(effectiveColor) || '#4c8036';
  colorInput.value = normalized;
  colorPicker.value = normalized;

  linkInput.value = metadata.link || '';

  colorPicker.oninput = () => {
    colorInput.value = colorPicker.value;
  };
  colorInput.oninput = () => {
    const norm = normalizeHexColor(colorInput.value);
    if (norm) colorPicker.value = norm;
  };

  backdrop.classList.add('show');
  modal.classList.add('show');

  setTimeout(() => typeSelect.focus(), 100);

  saveBtn.onclick = () => processEditAccount(accountName);
}

function hideEditAccountModal() {
  document.getElementById('edit-account-modal-backdrop').classList.remove('show');
  document.getElementById('edit-account-modal').classList.remove('show');
}

async function processEditAccount(accountName) {
  if (IS_LOADING) return;

  const typeSelect = document.getElementById('edit-account-type');
  const limitInput = document.getElementById('edit-account-limit');
  const aprInput   = document.getElementById('edit-account-apr');
  const valueInput = document.getElementById('edit-account-value');
  const colorInput = document.getElementById('edit-account-color');
  const linkInput  = document.getElementById('edit-account-link');

  const newType  = (typeSelect.value || 'bk').trim();
  const newLimit = limitInput.value ? Number(limitInput.value) : null;
  const newAPR   = Number(aprInput.value);
  const newValue = Number(valueInput.value);
  const newLink  = linkInput.value ? linkInput.value.trim() : '';

  const newColor = normalizeHexColor(colorInput.value);

  const meta = ACCOUNT_METADATA.get(accountName) || {};
  meta.limit = (newLimit && newLimit > 0) ? newLimit : null;
  meta.color = newColor || null;
  meta.link  = newLink || null;
  ACCOUNT_METADATA.set(accountName, meta);

  const account = SNAP?.accounts?.find(a => a.name === accountName);
  if (account) {
    account.type = newType;
    account.apr  = isNaN(newAPR) ? account.apr : newAPR;
  }

  saveStateToURL();
  hideEditAccountModal();

  const series = SNAP?.series?.[accountName];
  const currentValue = series?.last ?? 0;

  if (!isNaN(newValue) && newValue !== currentValue) {
    setLoading(true, 'Updating account value…');
    try {
      const body = new URLSearchParams({ 
        payload: JSON.stringify({ 
          entries: [{ account: accountName, value: newValue }] 
        }) 
      });

      const res = await fetch(`${API_BASE}?route=submit`, { method: 'POST', body });
      const text = await res.text();
      const j = JSON.parse(text);

      if (!j.ok) {
        throw new Error(j.error || 'Submit failed');
      }

      showToast('Account updated! Refreshing…', 'success');
      await fetchSnapshot();
    } catch (e) {
      console.error('Update error:', e);
      setLoading(false);
      showToast('Failed to update: ' + e.message, 'error', 5000);
    }
  } else {
    showToast('Account settings updated!', 'success');
    renderAll();
  }
}

/* ============================================
    EDIT TYPE COLOR MODAL
   ============================================ */
function getTypeEffectiveColor(typeCode) {
  const override = TYPE_META_OVERRIDES.get(typeCode);
  if (override && override.color) return override.color;

  const metaAPI = SNAP?.typeMeta?.[typeCode];
  if (metaAPI && metaAPI.color) return normalizeHexColor(metaAPI.color) || null;

  if (typeCode === 'cc' || typeCode === 'bill') return '#a02d2a';
  return '#4c8036';
}

function showEditTypeModal(typeCode, labelText) {
  if (IS_LOADING) return;

  const backdrop = document.getElementById('edit-type-modal-backdrop');
  const modal    = document.getElementById('edit-type-modal');
  const nameEl   = document.getElementById('edit-type-name');
  const picker   = document.getElementById('edit-type-color-picker');
  const input    = document.getElementById('edit-type-color');
  const saveBtn  = document.getElementById('edit-type-save');

  nameEl.textContent = `${labelText} (${typeCode})`;

  const current = getTypeEffectiveColor(typeCode) || '#4c8036';
  const norm = normalizeHexColor(current) || '#4c8036';
  picker.value = norm;
  input.value  = norm;

  picker.oninput = () => { input.value = picker.value; };
  input.oninput  = () => {
    const norm = normalizeHexColor(input.value);
    if (norm) picker.value = norm;
  };

  backdrop.classList.add('show');
  modal.classList.add('show');

  saveBtn.onclick = () => processEditType(typeCode);
}

function hideEditTypeModal() {
  document.getElementById('edit-type-modal-backdrop').classList.remove('show');
  document.getElementById('edit-type-modal').classList.remove('show');
}

function processEditType(typeCode) {
  const input = document.getElementById('edit-type-color');
  const color = normalizeHexColor(input.value);

  if (!color) {
    showToast('Please enter a valid 6-digit hex color (e.g. #4C8036).', 'error', 4000);
    return;
  }

  TYPE_META_OVERRIDES.set(typeCode, { color });
  saveStateToURL();
  hideEditTypeModal();
  showToast('Type color updated!', 'success', 2000);
  renderAll();
}

/* ============================================
    DATA FETCHING
   ============================================ */
async function fetchSnapshot() {
  if (IS_LOADING) return;
  setLoading(true, 'Loading snapshot…');

  try {
    const res = await fetch(`${API_BASE}?route=snapshot&ts=${Date.now()}&timeframe=${TIMEFRAME}`);
    const text = await res.text();

    let j;
    try { 
      j = JSON.parse(text); 
    } catch {
      console.error('Non-JSON response:', text); 
      showToast('Error: API returned non-JSON. Check console.', 'error', 5000);
      setLoading(false);
      return;
    }

    if (!j.ok) {
      console.error('Snapshot error:', j); 
      showToast('Error: ' + (j.error || 'snapshot failed'), 'error', 5000);
      setLoading(false);
      return;
    }

    SNAP = j;
    console.log('Snapshot loaded:', SNAP); 

    setLoading(false);
    renderAll();

  } catch (err) {
    console.error('Fetch failed:', err); 
    setLoading(false);
    showToast('Fetch failed (see console)', 'error', 5000);
  }
}

/* ============================================
    URL STATE (muted + metadata)
   ============================================ */
function loadStateFromURL() {
  const hash = window.location.hash.substring(1);
  const params = new URLSearchParams(hash);

  const mutedParam = params.get('muted');
  if (mutedParam) {
    MUTED_ACCOUNTS = new Set(mutedParam.split(',').filter(a => a));
  }

  const mutedTypesParam = params.get('mutedTypes');
  if (mutedTypesParam) {
    MUTED_TYPES = new Set(mutedTypesParam.split(',').filter(t => t));
  }

  const limitsParam = params.get('limits');
  const accountMetaParam = params.get('acctMeta');
  const typeMetaParam = params.get('typeMeta');

  ACCOUNT_METADATA = new Map();
  if (accountMetaParam) {
    try {
      const metaObj = JSON.parse(decodeURIComponent(accountMetaParam));
      Object.entries(metaObj).forEach(([account, meta]) => {
        ACCOUNT_METADATA.set(account, {
          limit: typeof meta.limit === 'number' ? meta.limit : null,
          color: meta.color ? normalizeHexColor(meta.color) : null,
          link: meta.link || null
        });
      });
    } catch (e) {
      console.error('Failed to parse acctMeta from URL:', e);
    }
  } else if (limitsParam) {
    try {
      const limitsData = JSON.parse(decodeURIComponent(limitsParam));
      Object.entries(limitsData).forEach(([account, limit]) => {
        ACCOUNT_METADATA.set(account, { limit: Number(limit) });
      });
    } catch (e) {
      console.error('Failed to parse limits from URL:', e);
    }
  }

  TYPE_META_OVERRIDES = new Map();
  if (typeMetaParam) {
    try {
      const typeObj = JSON.parse(decodeURIComponent(typeMetaParam));
      Object.entries(typeObj).forEach(([code, meta]) => {
        if (meta && meta.color) {
          const norm = normalizeHexColor(meta.color);
          if (norm) TYPE_META_OVERRIDES.set(code, { color: norm });
        }
      });
    } catch (e) {
      console.error('Failed to parse typeMeta from URL:', e);
    }
  }
}

function saveStateToURL() {
  const params = new URLSearchParams();

  const mutedArray = Array.from(MUTED_ACCOUNTS);
  if (mutedArray.length > 0) {
    params.set('muted', mutedArray.join(','));
  }

  const mutedTypesArray = Array.from(MUTED_TYPES);
  if (mutedTypesArray.length > 0) {
    params.set('mutedTypes', mutedTypesArray.join(','));
  }

  const acctMetaObj = {};
  ACCOUNT_METADATA.forEach((meta, accountName) => {
    const m = {};
    if (meta.limit) m.limit = meta.limit;
    if (meta.color) m.color = meta.color;
    if (meta.link)  m.link  = meta.link;
    if (Object.keys(m).length > 0) {
      acctMetaObj[accountName] = m;
    }
  });
  if (Object.keys(acctMetaObj).length > 0) {
    params.set('acctMeta', encodeURIComponent(JSON.stringify(acctMetaObj)));
  }

  const typeMetaObj = {};
  TYPE_META_OVERRIDES.forEach((meta, typeCode) => {
    if (meta.color) {
      typeMetaObj[typeCode] = { color: meta.color };
    }
  });
  if (Object.keys(typeMetaObj).length > 0) {
    params.set('typeMeta', encodeURIComponent(JSON.stringify(typeMetaObj)));
  }

  window.location.hash = params.toString();
}

function toggleAccountMute(accountName) {
  if (MUTED_ACCOUNTS.has(accountName)) {
    MUTED_ACCOUNTS.delete(accountName);
  } else {
    MUTED_ACCOUNTS.add(accountName);
  }
  saveStateToURL();
  renderAll();
}

function isAccountMuted(accountName) {
  return MUTED_ACCOUNTS.has(accountName);
}

function toggleTypeMute(typeCode) {
  if (MUTED_TYPES.has(typeCode)) {
    MUTED_TYPES.delete(typeCode);
  } else {
    MUTED_TYPES.add(typeCode);
  }
  saveStateToURL();
  renderAll();
}

function isTypeMuted(typeCode) {
  return MUTED_TYPES.has(typeCode);
}

function isAccountGloballyHidden(account) {
  if (isAccountMuted(account.name)) return true;
  const t = account.type || 'bk';
  return isTypeMuted(t);
}

/* ============================================
    RENDERING
   ============================================ */
function renderAll() {
  renderSummary();
  renderInterestSummary();
  renderStatusbar();
  renderChart();
  renderTypeSummary();
  renderAccounts();
}

function renderSummary() {
  const summaryEl = document.getElementById('financial-summary');
  if (!summaryEl || !SNAP || !SNAP.accounts) return;

  if (!SNAP.dateAxis || SNAP.dateAxis.length === 0) {
    summaryEl.innerHTML = 'No Data';
    return;
  }

  let assets = 0;
  let debts = 0;

  SNAP.accounts.forEach(a => {
    if (isAccountGloballyHidden(a)) return;
    const s = SNAP.series[a.name] || {};
    const last = s?.last ?? 0;
    if (last >= 0) {
      assets += last;
    } else {
      debts += Math.abs(last);
    }
  });

  const assetClass = assets > debts ? 'bold-value' : '';
  const debtClass  = debts > assets ? 'bold-value' : '';

  const assetString = `<span class="summary-asset ${assetClass}">${formatMoney(assets)}</span>`;
  const debtString  = `<span class="summary-debt ${debtClass}">${formatMoney(debts)}</span>`;

  summaryEl.innerHTML = `${assetString} <span style="font-weight: 300;">|</span> ${debtString}`;
}

function renderInterestSummary() {
  const summaryEl = document.getElementById('interest-summary');
  if (!summaryEl || !SNAP || !SNAP.accounts) return;

  let totalEarnings = 0;
  let totalCosts = 0;
  let periodLabel = '';

  SNAP.accounts.forEach(a => {
    if (isAccountGloballyHidden(a)) return;

    const s = SNAP.series[a.name] || {};
    const last = s?.last ?? 0;
    const apr = a.apr || 0;

    if (apr === 0 || last === 0) return;

    const dailyRate = (last * apr) / 365;
    let interestAmount = 0;

    switch (TIMEFRAME) {
      case 'today':
        interestAmount = dailyRate * 1;
        periodLabel = '/dy';
        break;
      case '7d':
        interestAmount = dailyRate * 7;
        periodLabel = '/wk';
        break;
      case '14d':
        interestAmount = dailyRate * 14;
        periodLabel = '/2w';
        break;
      case '30d':
        interestAmount = dailyRate * 30;
        periodLabel = '/mo';
        break;
      case '90d':
        interestAmount = dailyRate * 90;
        periodLabel = '/qt';
        break;
      case '1y':
      case 'ytd':
      case 'all':
        interestAmount = last * apr;
        periodLabel = '/yr';
        break;
    }

    if (interestAmount > 0) {
      totalEarnings += interestAmount;
    } else {
      totalCosts += interestAmount;
    }
  });

  if (Math.abs(totalEarnings) < 0.01 && Math.abs(totalCosts) < 0.01) {
    summaryEl.innerHTML = '';
    return;
  }

  const earningsStr = totalEarnings >= 0.01 
    ? `<span class="interest-earned">+${formatMoney(totalEarnings)}${periodLabel}</span>` 
    : '';

  const costsStr = Math.abs(totalCosts) >= 0.01 
    ? `<span class="interest-cost">${formatMoney(totalCosts)}${periodLabel}</span>` 
    : '';

  const displayParts = [];
  if (earningsStr) displayParts.push(earningsStr);
  if (costsStr) displayParts.push(costsStr);

  if (displayParts.length > 0) {
    summaryEl.innerHTML = `Interest: ${displayParts.join(' <span style="font-weight: 300;">|</span> ')}`;
  } else {
    summaryEl.innerHTML = '';
  }
}

function renderTypeSummary() {
  const container = document.getElementById('typeFilterRow');
  if (!container || !SNAP || !SNAP.accounts) return;

  container.hidden = false;
  container.innerHTML = '';

  const typeTotals = {};
  const typeMeta = SNAP.typeMeta || {};

  Object.keys(typeMeta).forEach(code => {
    typeTotals[code] = 0;
  });

  SNAP.accounts.forEach(a => {
    const s = SNAP.series[a.name] || {};
    const last = s?.last ?? 0;
    const typeCode = a.type || 'bk';
    if (typeTotals[typeCode] == null) typeTotals[typeCode] = 0;
    if (isAccountMuted(a.name)) return; // account mute removes from type total
    typeTotals[typeCode] += last;
  });

  const metaKeys = Object.keys(typeTotals);
  const preferredOrder = ['bk', 'cc', 'bill', 'ii', 'sv'];
  const orderedCodes = [];

  preferredOrder.forEach(code => {
    if (metaKeys.includes(code)) orderedCodes.push(code);
  });
  metaKeys.forEach(code => {
    if (!orderedCodes.includes(code)) orderedCodes.push(code);
  });

  orderedCodes.forEach(typeKey => {
    const total = typeTotals[typeKey] || 0;
    const meta = typeMeta[typeKey] || {};
    const labelBase = TYPE_LABELS[typeKey] || meta.label || typeKey;
    const label = labelBase.toUpperCase();
    const colorClass = total >= 0 ? 'positive' : 'negative';
    const signPrefix = total > 0 ? '+' : '';
    const typeColor = getTypeEffectiveColor(typeKey);

    const typeItem = document.createElement('div');
    typeItem.className = 'type-item';
    if (isTypeMuted(typeKey)) typeItem.classList.add('muted');

    const valueEl = document.createElement('div');
    valueEl.className = `type-value ${colorClass}`;
    valueEl.textContent = `${signPrefix}${formatMoney(total)}`;
    typeItem.appendChild(valueEl);

    const labelEl = document.createElement('div');
    labelEl.className = 'type-label';
    labelEl.textContent = label;
    labelEl.style.color = typeColor;
    labelEl.title = 'Double-click to change this Type color';
    labelEl.addEventListener('dblclick', () => {
      showEditTypeModal(typeKey, label);
    });
    typeItem.appendChild(labelEl);

    const toggleLabel = document.createElement('label');
    toggleLabel.className = 'type-toggle-label';

    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.dataset.typeCode = typeKey;
    cb.checked = !isTypeMuted(typeKey);

    cb.addEventListener('change', () => {
      toggleTypeMute(typeKey);
    });

    toggleLabel.appendChild(cb);
    toggleLabel.appendChild(document.createTextNode(' show'));
    typeItem.appendChild(toggleLabel);

    container.appendChild(typeItem);
  });
}

function renderStatusbar() {
  const statusbarEl = document.getElementById('statusbar');
  if (!statusbarEl || !SNAP || !SNAP.totals || !SNAP.dateAxis) return;

  if (SNAP.dateAxis.length === 0) {
    statusbarEl.innerHTML = '';
    return;
  }

  let assets = 0;
  let debts = 0;

  SNAP.accounts.forEach(a => {
    if (isAccountGloballyHidden(a)) return;
    const s = SNAP.series[a.name] || {};
    const last = s?.last ?? 0;
    if (last >= 0) {
      assets += last;
    } else {
      debts += Math.abs(last);
    }
  });

  const total = assets + debts;

  if (total === 0) {
    statusbarEl.innerHTML = '<span class="status-positive">' + '█ '.repeat(100) + '</span>';
    return;
  }

  const totalBlocks = 100;
  const assetBlocks = Math.round((assets / total) * totalBlocks);
  const debtBlocks = totalBlocks - assetBlocks;

  const assetBar = '█ '.repeat(assetBlocks);
  const debtBar  = '█ '.repeat(debtBlocks);

  statusbarEl.innerHTML = `<span class="status-positive">${assetBar}</span><span class="status-negative">${debtBar}</span>`;
}

function renderChart() {
  if (!SNAP || !window.google || !google.visualization) return;

  const labels = SNAP.dateAxis; 
  if (!labels || labels.length === 0) {
    document.getElementById('chart').innerHTML =
      '<div style="text-align:center; padding-top: 20px; color: #888;">No data for this timeframe.</div>';
    return;
  }

  const styles = getComputedStyle(document.documentElement);
  const pos   = styles.getPropertyValue('--c-pos').trim();
  const neg   = styles.getPropertyValue('--c-neg').trim();
  const black = styles.getPropertyValue('--c-black').trim();
  const textStyle = { color: black, fontName: 'system-ui' };

  const data = new google.visualization.DataTable();
  data.addColumn('string', 'Date'); 
  let rows = [];

  if (MODE === 'totals') {
    data.addColumn('number', 'Assets');
    data.addColumn('number', 'Debts');

    for (let i = 0; i < labels.length; i++) { 
      let assets = 0;
      let debts = 0;

      SNAP.accounts.forEach(a => {
        if (isAccountGloballyHidden(a)) return;
        const v = SNAP.series[a.name]?.monthly?.[i] ?? 0;
        if (v >= 0) {
          assets += v;
        } else {
          debts += v;
        }
      });

      rows.push([labels[i], assets, debts]);
    }
  } else if (MODE === 'types') {
    const typeSeries = SNAP.typeSeries || {};
    const typeMeta = SNAP.typeMeta || {};
    const seriesKeys = Object.keys(typeSeries);

    const preferredOrder = ['bk', 'cc', 'bill', 'ii', 'sv'];
    const orderedCodes = [];
    preferredOrder.forEach(code => {
      if (seriesKeys.includes(code)) orderedCodes.push(code);
    });
    seriesKeys.forEach(code => {
      if (!orderedCodes.includes(code)) orderedCodes.push(code);
    });

    const visibleTypes = orderedCodes.filter(code => !isTypeMuted(code));

    visibleTypes.forEach(code => {
      const baseLabel = TYPE_LABELS[code] || typeMeta[code]?.label || code;
      data.addColumn('number', baseLabel);
    });

    for (let i = 0; i < labels.length; i++) {
      const row = [labels[i]];
      visibleTypes.forEach(code => {
        const seriesArr = typeSeries[code] || [];
        const v = Number(seriesArr[i] ?? 0);
        row.push(v);
      });
      rows.push(row);
    }
  } else {
    const visibleAccounts = SNAP.accounts.filter(a => !isAccountGloballyHidden(a));
    visibleAccounts.forEach(a => data.addColumn('number', a.name));

    for (let i = 0; i < labels.length; i++) {
      const row = [labels[i]]; 
      visibleAccounts.forEach(a => {
        const v = SNAP.series[a.name]?.monthly?.[i] ?? 0;
        row.push(Number(v));
      });
      rows.push(row);
    }
  }

  data.addRows(rows);

  let minV = 0, maxV = 0;
  for (const r of rows) {
    for (let i = 1; i < r.length; i++) {
      const v = Number(r[i]) || 0;
      if (v < minV) minV = v;
      if (v > maxV) maxV = v;
    }
  }
  const maxAbs = Math.max(Math.abs(minV), Math.abs(maxV), 100);

  let chartColors;
  if (MODE === 'totals') {
    chartColors = [pos, neg];
  } else if (MODE === 'types') {
    const typeSeries = SNAP.typeSeries || {};
    const seriesKeys = Object.keys(typeSeries);
    const preferredOrder = ['bk', 'cc', 'bill', 'ii', 'sv'];
    const orderedCodes = [];
    preferredOrder.forEach(code => {
      if (seriesKeys.includes(code)) orderedCodes.push(code);
    });
    seriesKeys.forEach(code => {
      if (!orderedCodes.includes(code)) orderedCodes.push(code);
    });
    const visibleTypes = orderedCodes.filter(code => !isTypeMuted(code));
    chartColors = visibleTypes.map(code => getTypeEffectiveColor(code));
  } else {
    const visibleAccounts = SNAP.accounts.filter(a => !isAccountGloballyHidden(a));
    chartColors = visibleAccounts.map(a => {
      const meta = ACCOUNT_METADATA.get(a.name) || {};
      const baseColor = meta.color || a.color;
      if (baseColor) return normalizeHexColor(baseColor) || (a.kind === 'debt' ? neg : pos);
      return a.kind === 'debt' ? neg : pos;
    });
  }

  const options = {
    height: Math.max(240, Math.round(window.innerHeight * 0.30)),
    backgroundColor: { fill: 'transparent' },
    chartArea: { width: '90%', height: '70%' },
    legend: { position: 'top', alignment: 'center', textStyle: textStyle },
    hAxis: { 
      slantedText: false, 
      textStyle: textStyle,
      showTextEvery: labels.length > 30 ? Math.ceil(labels.length / 15) : 1
    },
    vAxis: { 
      viewWindow: { min: -maxAbs * 1.05, max: maxAbs * 1.05 }, 
      baseline: 0, 
      baselineColor: black,
      gridlines: { color: black, opacity: 0.1 },
      textStyle: textStyle
    },
    isStacked: true,
    colors: chartColors,
    animation: {
      duration: 500,
      easing: 'out'
    }
  };

  const chart = new google.visualization.ColumnChart(document.getElementById('chart'));
  chart.draw(data, options);
}

const signOf = (n) => (Number(n) < 0 ? 'neg' : 'pos');

function formatMoney(n) {
  const val = Number(n) || 0;
  const sign = val < 0 ? '−' : '';
  const abs = Math.abs(val);
  const displayValue = Math.trunc(abs);

  return `${sign}${displayValue.toLocaleString(undefined, { 
    minimumFractionDigits: 0, 
    maximumFractionDigits: 0 
  })}`;
}

/* Limit color helper (for CC limit visualization) */
function getLimitColor(currentBalance, limit) {
  const absBalance = Math.abs(currentBalance);
  const utilization = absBalance / limit;

  if (currentBalance >= 0) {
    return '#4c8036';
  }

  if (utilization > 1.0) {
    return '#d85140';
  }

  const startColor = { r: 76, g: 128, b: 54 };   // green
  const endColor   = { r: 160, g: 45,  b: 42 };  // red

  const r = Math.round(startColor.r + (endColor.r - startColor.r) * utilization);
  const g = Math.round(startColor.g + (endColor.g - startColor.g) * utilization);
  const b = Math.round(startColor.b + (endColor.b - startColor.b) * utilization);

  return `rgb(${r}, ${g}, ${b})`;
}

function renderAccounts() {
  const root = document.getElementById('accounts');
  root.innerHTML = '';
  if (!SNAP || !SNAP.accounts) return;

  SNAP.accounts.forEach(a => {
    const s = SNAP.series[a.name] || {};
    const last = s?.last ?? 0;

    const row  = document.createElement('div');
    row.className = 'row';

    const left = document.createElement('div');
    left.className = 'left';

    const right = document.createElement('div');
    right.className = 'right';

    const accountDetails = document.createElement('div');
    accountDetails.className = 'account-details';

    const identityWrap = document.createElement('div');
    identityWrap.style.cssText =
      'display:flex; align-items:baseline; gap:10px; flex-wrap:nowrap; min-width:0';

    const lastEl = document.createElement('span');
    lastEl.className = 'lastval';
    lastEl.textContent = formatMoney(last); 
    lastEl.dataset.sign = signOf(last);

    const nameEl = document.createElement('span');
    nameEl.className = 'name';

    const meta = ACCOUNT_METADATA.get(a.name) || {};
    const effectiveColor = meta.color || a.color;
    if (effectiveColor) {
      const norm = normalizeHexColor(effectiveColor);
      if (norm) nameEl.style.color = norm;
    }

    nameEl.textContent = a.name;
    if (meta.link) {
      nameEl.style.textDecoration = 'underline';
      nameEl.style.textDecorationStyle = 'dotted';
      nameEl.title = 'Open account link in new tab';
      nameEl.addEventListener('click', (e) => {
        if (LONG_PRESS_TIMER) {
          clearTimeout(LONG_PRESS_TIMER);
        }
        window.open(meta.link, '_blank', 'noopener');
      });
    }

    let pressStartTime = 0;

    const startLongPress = () => {
      pressStartTime = Date.now();
      LONG_PRESS_TIMER = setTimeout(() => {
        showAccountMenu(a.name);
      }, LONG_PRESS_DURATION);
    };

    const clearLongPress = () => {
      if (LONG_PRESS_TIMER) {
        clearTimeout(LONG_PRESS_TIMER);
        LONG_PRESS_TIMER = null;
      }
    };

    nameEl.addEventListener('mousedown', startLongPress);
    nameEl.addEventListener('mouseup', clearLongPress);
    nameEl.addEventListener('mouseleave', clearLongPress);
    nameEl.addEventListener('touchstart', startLongPress);
    nameEl.addEventListener('touchend', clearLongPress);

    identityWrap.appendChild(lastEl);
    identityWrap.appendChild(nameEl);
    accountDetails.appendChild(identityWrap);

    if (a.type === 'cc' && meta.limit) {
      const limitEl = document.createElement('span');
      limitEl.className = 'limit';
      const limitValue = meta.limit;
      const limitColor = getLimitColor(last, limitValue);
      limitEl.style.color = limitColor;
      limitEl.textContent = `$${limitValue.toLocaleString()}`;
      accountDetails.appendChild(limitEl);
    }

    const aprEl = document.createElement('span');
    aprEl.className = 'apr';

    const apr = a.apr || 0;
    let interestAmount = 0;
    let periodLabel = '';

    if (apr > 0 && last !== 0) {
      const dailyRate = (last * apr) / 365;

      switch (TIMEFRAME) {
        case 'today':
          interestAmount = dailyRate * 1;
          periodLabel = '/dy';
          break;
        case '7d':
          interestAmount = dailyRate * 7;
          periodLabel = '/wk';
          break;
        case '14d':
          interestAmount = dailyRate * 14;
          periodLabel = '/2w';
          break;
        case '30d':
          interestAmount = dailyRate * 30;
          periodLabel = '/mo';
          break;
        case '90d':
          interestAmount = dailyRate * 90;
          periodLabel = '/qt';
          break;
        case '1y':
        case 'ytd':
        case 'all':
          interestAmount = last * apr;
          periodLabel = '/yr';
          break;
      }
    }

    let aprHTML = `APR: ${(apr * 100).toFixed(2)}%`;

    if (Math.abs(interestAmount) >= 0.01) {
      const sign = interestAmount >= 0 ? '+' : '';
      const color = interestAmount >= 0 ? 'var(--c-pos)' : 'var(--c-neg)';
      aprHTML += `<br><span style="color: ${color}">${sign}${formatMoney(interestAmount)}${periodLabel}</span>`;
    }

    aprEl.innerHTML = aprHTML;
    accountDetails.appendChild(aprEl);

    const inputLine = document.createElement('div');
    inputLine.className = 'input-line';

    const inp = document.createElement('input');
    inp.type = 'number';
    inp.placeholder = 'Add new value…';
    inp.step = '0.01';
    inp.setAttribute('aria-label', `New value for ${a.name}`);
    inp.dataset.accountName = a.name;

    if (last > 0) {
      inp.style.backgroundColor = 'var(--c-tint-pos)';
    } else if (last < 0) {
      inp.style.backgroundColor = 'var(--c-tint-neg)';
    } else {
      inp.style.backgroundColor = 'var(--c-white)';
    }

    inp.addEventListener('keydown', async (ev) => {
      if (ev.key === 'Enter') {
        await submitEntries([{ account: a.name, value: inp.value, inputEl: inp }]);
      }
    });

    const muteWrapper = document.createElement('label');
    muteWrapper.className = 'mute-checkbox';
    muteWrapper.setAttribute('aria-label', `Toggle ${a.name} visibility`);
    muteWrapper.title = `Show/hide ${a.name}`;

    const muteCheck = document.createElement('input');
    muteCheck.type = 'checkbox';
    muteCheck.checked = !isAccountMuted(a.name);
    muteCheck.setAttribute('aria-label', `Show ${a.name}`);

    muteCheck.addEventListener('change', () => {
      toggleAccountMute(a.name);
    });

    const muteSlider = document.createElement('span');
    muteSlider.className = 'mute-checkbox-slider';

    muteWrapper.appendChild(muteCheck);
    muteWrapper.appendChild(muteSlider);

    inputLine.appendChild(inp);
    inputLine.appendChild(muteWrapper);

    left.appendChild(accountDetails);
    left.appendChild(inputLine);

    if (isAccountMuted(a.name)) {
      row.classList.add('muted');
    }

    const vals = document.createElement('div');
    vals.className = 'values';

    (s.lastN || []).forEach(v => {
      const isObject = (typeof v === 'object' && v !== null && v.value !== undefined);
      const val = Number(isObject ? v.value : v);
      const date = isObject ? v.date : null;

      const readableValue = formatMoney(val);

      const chip = document.createElement('span');
      chip.className = 'chip';
      chip.dataset.sign = signOf(val);
      chip.textContent = readableValue;
      chip.dataset.value = val;

      if (date) {
        chip.dataset.date = date;
        chip.dataset.account = a.name;
        chip.dataset.readableValue = readableValue;

        chip.addEventListener('click', () => {
          showEditChipModal(a.name, date, val, readableValue);
        });
      } else {
        chip.classList.add('no-delete');
        chip.title = "Old data format - re-deploy CODE.JS";
      }

      vals.appendChild(chip);
    });

    right.appendChild(vals);

    const bar = document.createElement('h4');
    bar.className = 'ratio-bar';

    const assetSpan = document.createElement('span');
    assetSpan.style.color = 'var(--c-pos)';

    const debtSpan = document.createElement('span');
    debtSpan.style.color = 'var(--c-neg)';

    const lastIndex = SNAP.dateAxis.length - 1;
    const totalAssets = Number(SNAP.totals.assets?.[lastIndex]) || 0;
    const totalDebtsRaw = Number(SNAP.totals.debts?.[lastIndex]) || 0;
    const totalDebts = Math.abs(totalDebtsRaw);

    if (last >= 0 && totalAssets > 0) {
      const percentage = (last / totalAssets) * 100;
      const blocks = percentage >= 5 ? Math.max(1, Math.round((last / totalAssets) * 10)) : 0;
      assetSpan.textContent = '█ '.repeat(blocks);
      debtSpan.textContent = '';
    } else if (last < 0 && totalDebts > 0) {
      const absLast = Math.abs(last);
      const percentage = (absLast / totalDebts) * 100;
      const blocks = percentage >= 5 ? Math.max(1, Math.round((absLast / totalDebts) * 10)) : 0;
      assetSpan.textContent = '';
      debtSpan.textContent = '█ '.repeat(blocks);
    } else {
      assetSpan.textContent = '';
      debtSpan.textContent = '';
    }

    bar.appendChild(assetSpan);
    bar.appendChild(debtSpan);
    right.appendChild(bar);

    row.appendChild(left);
    row.appendChild(right);
    root.appendChild(row);
  });
}

/* ============================================
    SUBMISSION
   ============================================ */
async function submitAll() {
  const entries = [];

  document.querySelectorAll('.row .left input[type="number"]').forEach(inp => {
    const v = inp.value.trim();
    if (v !== '') {
      entries.push({ 
        account: inp.dataset.accountName, 
        value: Number(v),
        inputEl: inp
      });
    }
  });

  if (entries.length === 0) {
    showToast('No values entered to submit.', 'info');
    return;
  }

  await submitEntries(entries);
}

async function submitEntries(entries) {
  if (IS_LOADING) return;
  setLoading(true, 'Submitting entries…');

  entries.forEach(e => e.inputEl?.classList.add('submitting'));

  try {
    const validEntries = entries
      .map(e => ({ account: e.account, value: e.value }))
      .filter(e => e.account && !isNaN(e.value));

    if (validEntries.length === 0) {
      showToast('No valid entries to submit.', 'error');
      setLoading(false);
      entries.forEach(e => e.inputEl?.classList.remove('submitting'));
      return;
    }

    const body = new URLSearchParams({ 
      payload: JSON.stringify({ entries: validEntries }) 
    });
    const res = await fetch(`${API_BASE}?route=submit`, { method: 'POST', body });
    const text = await res.text();

    let j;
    try { 
      j = JSON.parse(text); 
    } catch {
      console.error('Submit non-JSON:', text);
      showToast('Submit failed (non-JSON response)', 'error', 5000);
      setLoading(false);
      entries.forEach(e => e.inputEl?.classList.remove('submitting'));
      return;
    }

    if (!j.ok) {
      console.error('Submit JSON error:', j);
      showToast('Submit failed: ' + (j.error || 'Unknown'), 'error', 5000);
      setLoading(false);
      entries.forEach(e => e.inputEl?.classList.remove('submitting'));
      return;
    }

    showToast('Submit successful! Refreshing…', 'success');
    entries.forEach(e => {
      e.inputEl?.classList.add('submitted-ok');
      e.inputEl.value = '';
      setTimeout(() => e.inputEl?.classList.remove('submitted-ok'), 800);
    });

    await fetchSnapshot();

  } catch (e) {
    console.error(e);
    setLoading(false);
    showToast('Network error submitting data.', 'error', 5000);
    entries.forEach(e => e.inputEl?.classList.remove('submitting'));
  }

  setLoading(false);
}

/* ============================================
    INITIALIZATION
   ============================================ */
document.addEventListener('DOMContentLoaded', () => {
  // 1) Theme first so the page paints in the right mode quickly
  initTheme();

  // 2) Existing URL/hash state for mutes, limits, etc.
  loadStateFromURL();

  // Theme toggle button hookup
  const themeBtn = document.getElementById('theme-toggle-btn');
  if (themeBtn) {
    themeBtn.addEventListener('click', toggleTheme);
  }

  // Update Google Sheet link in footer
  const sheetLink = document.querySelector('footer a[href*="spreadsheets"]');
  if (sheetLink && SHEET_ID && SHEET_ID !== 'YOUR_SHEET_ID_HERE') {
    sheetLink.href = `https://docs.google.com/spreadsheets/d/${SHEET_ID}`;
  }

  document.getElementById('refresh').addEventListener('click', fetchSnapshot);
  document.getElementById('submitAll').addEventListener('click', submitAll);

  document.querySelectorAll('input[name="mode"]').forEach(r => {
    r.addEventListener('change', (e) => { 
      MODE = e.target.value; 
      renderChart();
    });
  });

  document.getElementById('timeframe').addEventListener('change', (e) => {
    TIMEFRAME = e.target.value;
    fetchSnapshot();
  });

  // ...keep the rest of your existing init hooks:
  // delete modal, edit chip modal, account menu, edit account modal, resize handler, google.charts loader, etc.
});

  document.getElementById('refresh').addEventListener('click', fetchSnapshot);
  document.getElementById('submitAll').addEventListener('click', submitAll);

  document.querySelectorAll('input[name="mode"]').forEach(r => {
    r.addEventListener('change', (e) => { 
      MODE = e.target.value; 
      renderChart();
    });
  });

  document.getElementById('timeframe').addEventListener('change', (e) => {
    TIMEFRAME = e.target.value;
    fetchSnapshot();
  });

  document.getElementById('delete-btn-cancel').addEventListener('click', hideDeleteConfirm);
  document.getElementById('delete-modal-backdrop').addEventListener('click', hideDeleteConfirm);

  document.getElementById('edit-chip-cancel').addEventListener('click', hideEditChipModal);
  document.getElementById('edit-chip-modal-backdrop').addEventListener('click', hideEditChipModal);

  document.getElementById('account-menu-cancel').addEventListener('click', hideAccountMenu);
  document.getElementById('account-menu-modal-backdrop').addEventListener('click', hideAccountMenu);

  document.getElementById('edit-account-cancel').addEventListener('click', hideEditAccountModal);
  document.getElementById('edit-account-modal-backdrop').addEventListener('click', hideEditAccountModal);

  document.getElementById('edit-type-cancel').addEventListener('click', hideEditTypeModal);
  document.getElementById('edit-type-modal-backdrop').addEventListener('click', hideEditTypeModal);

  window.addEventListener('resize', renderChart);

  if (window.google && google.charts) {
    google.charts.load('current', { packages: ['corechart'] });
    google.charts.setOnLoadCallback(fetchSnapshot);
  } else {
    const s = document.createElement('script');
    s.src = 'https://www.gstatic.com/charts/loader.js';
    s.onload = () => { 
      google.charts.load('current', { packages: ['corechart'] });
      google.charts.setOnLoadCallback(fetchSnapshot);
    };
    document.head.appendChild(s);
  }
});
</script>
</body>
</html>
