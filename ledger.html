/** * LedgerDB Web API (Apps Script) - v1f
 *
 * Endpoints:
 * GET  .../exec?route=snapshot&timeframe=<value>
 * POST .../exec?route=submit
 * POST .../exec?route=delete
 *
 * Changes in v1f:
 * - snapshot() 'today' timeframe is now granular
 * and plots every entry by "HH:MM".
 * - Refactored date axis generation for all timeframes.
 */

const SHEET_ACCOUNTS = 'Accounts';
const SHEET_VALUES   = 'Values';

/**
 * Handles GET requests.
 * @param {object} e - The event parameter.
 * @returns {ContentService.TextOutput} JSON response.
 */
function doGet(e) {
  const params = e && e.parameter ? e.parameter : {};
  const route = (params.route || '').toLowerCase();
  
  try {
    if (route === 'snapshot') {
      return jsonResponse(snapshot(params));
    }
    return jsonResponse({ ok: false, error: 'Unknown route' }, 404);
  } catch (err) {
    Logger.log('doGet Error: ' + err);
    return jsonResponse({ ok: false, error: 'Server error: ' + String(err) }, 500);
  }
}

/**
 * Handles POST requests.
 * @param {object} e - The event parameter.
 * @returns {ContentService.TextOutput} JSON response.
 */
function doPost(e) {
  try {
    const params = e && e.parameter ? e.parameter : {};
    const route = (params.route || '').toLowerCase();

    let body = {};
    if (params.payload) {
      try { body = JSON.parse(params.payload); } catch (err) {
        return jsonResponse({ ok: false, error: 'Invalid payload JSON: ' + String(err) }, 400);
      }
    } else if (e && e.postData && e.postData.contents) {
      try { body = JSON.parse(e.postData.contents); } catch (err) {
        return jsonResponse({ ok: false, error: 'Invalid post body JSON: ' + String(err) }, 400);
      }
    }

    if (route === 'submit') {
      return jsonResponse(handleSubmit(body));
    }
    if (route === 'delete') {
      return jsonResponse(handleDelete(body));
    }
    
    return jsonResponse({ ok: false, error: 'Unknown route' }, 404);
  } catch (err) {
    Logger.log('doPost Error: ' + err);
    return jsonResponse({ ok: false, error: 'Server error: ' + String(err) }, 500);
  }
}

/**
 * Creates a JSON response.
 * @param {object} obj - The object to stringify.
 * @returns {ContentService.TextOutput} The JSON output.
 */
function jsonResponse(obj, statusCode = 200) {
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

/** * Reads a sheet to an array of objects.
 * @param {string} name - The name of the sheet.
 * @returns {Array<object>} An array of row objects.
 */
function readSheet(name) {
  const sh = SpreadsheetApp.getActive().getSheetByName(name);
  if (!sh) throw new Error('Missing sheet: ' + name);
  const values = sh.getDataRange().getValues();
  if (values.length < 2) return [];
  const headers = values[0].map(String);
  return values.slice(1).map(row => {
    const o = {};
    headers.forEach((h, i) => o[h] = row[i]);
    return o;
  });
}

/** * Converts a Date object to an "YYYY-MM-DD" string in UTC.
 * @param {Date} d - The date object.
 * @returns {string} The formatted date string.
 */
function toISODate(d) {
  const y = d.getUTCFullYear();
  const m = String(d.getUTCMonth() + 1).padStart(2, '0');
  const da = String(d.getUTCDate()).padStart(2, '0');
  return `${y}-${m}-${da}`;
}

/** * Generates the data snapshot for the frontend.
 * @param {object} params - The query parameters, expecting `timeframe`.
 * @returns {object} The snapshot data.
 */
function snapshot(params) {
  // --- 1. Get Data (unchanged) ---
  const accountsRaw = readSheet(SHEET_ACCOUNTS);
  const valuesRaw = readSheet(SHEET_VALUES);

  // Normalize account metadata (unchanged from v1d)
  const accounts = accountsRaw.map((r, idx) => {
    let aprNum = 0;
    if (typeof r.APR === 'number') aprNum = r.APR;
    else if (typeof r.APR === 'string') {
      const s = r.APR.trim().replace('%', '');
      aprNum = Number(s);
      if (!isNaN(aprNum) && aprNum > 1) aprNum = aprNum / 100;
    }
    return {
      name: String(r.Account),
      kind: String(r.Kind).toLowerCase() === 'debt' ? 'debt' : 'asset',
      apr: Number(aprNum) || 0,
      color: r.Color && String(r.Color).trim() ? String(r.Color).trim() : null,
      sort: (typeof r.Sort === 'number') ? r.Sort : (parseInt(r.Sort, 10) || idx)
    };
  }).sort((a, b) => a.sort - b.sort);

  // --- 2. Build Account Map with Sorted Values (unchanged) ---
  const byAcct = new Map(accounts.map(a => [a.name, []]));
  valuesRaw.forEach(r => {
    const acct = String(r.Account);
    if (!byAcct.has(acct)) return;
    const d = new Date(r.Date);
    if (d.getFullYear() < 1970) return; 
    const v = Number(r.Value);
    if (!isFinite(v)) return;
    byAcct.get(acct).push({ date: d, value: v });
  });
  for (const arr of byAcct.values()) arr.sort((x, y) => x.date - y.date);

  // --- 3. NEW: Timeframe and Date Axis Generation ---
  const timeframe = params.timeframe || 'ytd';
  const now = new Date();
  // Set 'today' to midnight, UTC, for consistent date comparisons
  const today = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
  
  let startDate = new Date(today);
  let groupingMode = 'daily';
  let oldestDate = new Date(today);

  // Find the actual oldest date in all records
  if (timeframe === 'all' || timeframe === 'ytd') {
    for (const arr of byAcct.values()) {
      if (arr.length > 0 && arr[0].date < oldestDate) {
        oldestDate = arr[0].date;
      }
    }
  }

  // NEW: This array holds {label, endDate} objects
  const dateAxisInfo = []; 
  
  switch (timeframe) {
    case 'today':
      // 3. NEW: Granular 'today' logic
      groupingMode = 'today-granular';
      // Find all unique entry timestamps from today
      const todayUTCStart = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
      const timeSet = new Set();
      byAcct.forEach(arr => { 
        arr.forEach(entry => { 
          if (entry.date >= todayUTCStart) { 
            timeSet.add(entry.date.getTime()); 
          } 
        }); 
      });
      const sortedTimestamps = Array.from(timeSet).sort((a, b) => a - b);
      
      if (sortedTimestamps.length === 0) {
        // No entries today. Just show one label for "now".
        const hh = String(now.getUTCHours()).padStart(2, '0');
        const mm = String(now.getUTCMinutes()).padStart(2, '0');
        dateAxisInfo.push({ label: `${hh}:${mm}`, endDate: now });
      } else {
        sortedTimestamps.forEach(ts => {
          const d = new Date(ts);
          const hh = String(d.getUTCHours()).padStart(2, '0');
          const mm = String(d.getUTCMinutes()).padStart(2, '0');
          // Use the exact date object as the endDate for 'findLastValue'
          dateAxisInfo.push({ label: `${hh}:${mm}`, endDate: d });
        });
      }
      break;
    case '7d':
      startDate.setUTCDate(today.getUTCDate() - 6); // 6 days ago + today = 7 days
      groupingMode = 'daily';
      break;
    case '14d':
      startDate.setUTCDate(today.getUTCDate() - 13);
      groupingMode = 'daily';
      break;
    case '30d':
      startDate.setUTCDate(today.getUTCDate() - 29);
      groupingMode = 'daily';
      break;
    case '90d':
      startDate.setUTCDate(today.getUTCDate() - 89);
      groupingMode = 'daily';
      break;
    case '1y': // Last 12 months
      startDate = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth() - 11, 1));
      groupingMode = 'monthly';
      break;
    case 'all':
      startDate = new Date(Date.UTC(oldestDate.getUTCFullYear(), oldestDate.getUTCMonth(), 1));
      groupingMode = 'monthly';
      break;
    case 'ytd':
    default:
      startDate = new Date(Date.UTC(today.getUTCFullYear(), 0, 1)); // Jan 1st of this year
      groupingMode = 'monthly';
      break;
  }
  
  // NEW: Populate dateAxisInfo for daily/monthly modes
  if (groupingMode === 'daily') {
    let d = new Date(startDate);
    while (d <= today) {
      // End of the day UTC
      const endDate = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), 23, 59, 59));
      dateAxisInfo.push({ label: toISODate(d), endDate: endDate });
      d.setUTCDate(d.getUTCDate() + 1);
    }
  } else if (groupingMode === 'monthly') {
    let d = new Date(startDate);
    const endMonth = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), 1));
    while (d <= endMonth) {
      const ym = d.getUTCFullYear() + '-' + String(d.getUTCMonth() + 1).padStart(2, '0');
      // End of the month UTC
      const endDate = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth() + 1, 0, 23, 59, 59));
      dateAxisInfo.push({ label: ym, endDate: endDate });
      d.setUTCMonth(d.getUTCMonth() + 1);
    }
  }

  // --- 4. NEW: Data Series Generation ---
  
  /**
   * Finds the last known value for an account on or before a given date.
   * @param {Date} axisEndDate - The UTC end-of-period date to check against.
   * @param {Array} valueArray - The sorted array of {date, value} objects.
   * @returns {number} The last known value, or 0.
   */
  function findLastValueOnOrBefore(axisEndDate, valueArray) {
    for (let i = valueArray.length - 1; i >= 0; i--) {
      // valueArray[i].date is a JS Date object, can be compared directly
      if (valueArray[i].date <= axisEndDate) {
        return valueArray[i].value;
      }
    }
    return 0; // No value found before this date
  }
  
  const series = {};
  const totalsAssets = new Array(dateAxisInfo.length).fill(0);
  const totalsDebts = new Array(dateAxisInfo.length).fill(0);

  accounts.forEach(a => {
    const arr = byAcct.get(a.name) || [];
    
    // NEW: This array now iterates over dateAxisInfo
    const seriesData = dateAxisInfo.map((info, idx) => {
      // NEW: Use the endDate from our info object
      const v = findLastValueOnOrBefore(info.endDate, arr);
      
      if (a.kind === 'asset') totalsAssets[idx] += v;
      else totalsDebts[idx] += v;
      
      return v;
    });

    // Get last 4 entries (unchanged from v1d)
    const lastN = arr.slice(-4).map(x => {
      return { value: x.value, date: toISODate(x.date) };
    }).reverse();
    
    const last = arr.length ? arr[arr.length - 1].value : 0;
    
    // 'monthly' is the name the HTML expects for the chart data
    series[a.name] = { monthly: seriesData, lastN, last };
  });

  // --- 5. Return (New Shape) ---
  return {
    ok: true,
    as_of: toISODate(now),
    timeframe: timeframe,
    dateAxis: dateAxisInfo.map(info => info.label), // Replaces 'months'
    accounts,
    series,
    totals: { assets: totalsAssets, debts: totalsDebts }
  };
}

/** * Handles submission of new entries.
 * @param {object} body - The parsed request body, expecting `body.entries`.
 * @returns {object} A success/error object.
 */
function handleSubmit(body) {
  if (!body || !Array.isArray(body.entries) || body.entries.length === 0) {
    throw new Error('Missing or empty entries array');
  }
  // NEW: Use the *full* timestamp for "Today" view.
  // We use the local time from the server running the script.
  const now = new Date(); 

  const accRows = readSheet(SHEET_ACCOUNTS);
  const activeNames = new Set(accRows.map(r => String(r.Account)));

  const provided = new Map();
  body.entries.forEach(e => {
    const name = String(e.account);
    if (!activeNames.has(name)) return;
    const val = Number(e.value);
    if (!isFinite(val)) return;
    provided.set(name, val);
  });

  if (provided.size === 0) {
    throw new Error('No valid entries provided');
  }

  const latestByAcct = getLatestMap(activeNames);

  let updated = 0;
  let copied = 0;
  const rowsToWrite = [];

  for (const [name, val] of provided.entries()) {
    // NEW: Write the full timestamp
    rowsToWrite.push([now, name, val]); 
    latestByAcct.set(name, val);
    updated++;
  }

  // Get today's date (YYYY-MM-DD) for copy-forward logic
  const todayDateStr = toISODate(now);

  for (const name of activeNames) {
    if (provided.has(name)) continue;
    
    // Check if this account *already* has an entry for today
    const lastEntryInfo = latestByAcct.get(name + ':info');
    if (lastEntryInfo && lastEntryInfo.dateStr === todayDateStr) {
      // Already has an entry today, no need to copy forward
      continue;
    }

    const last = latestByAcct.get(name);
    const val = isFinite(last) ? last : 0;
    // NEW: Write the full timestamp
    rowsToWrite.push([now, name, val]); 
    copied++;
  }
  
  if (rowsToWrite.length > 0) {
    const shV = SpreadsheetApp.getActive().getSheetByName(SHEET_VALUES);
    if (!shV) throw new Error('Missing sheet: ' + SHEET_VALUES);
    shV.getRange(shV.getLastRow() + 1, 1, rowsToWrite.length, 3)
       .setValues(rowsToWrite);
  }

  return { ok: true, date: now.toISOString(), updated, copied_forward: copied };
}

/**
 * Handles deletion of a single entry.
 * @param {object} body - The parsed request body, expecting {account, date, value}.
 * @returns {object} A success/error object.
 */
function handleDelete(body) {
  const { account, date, value } = body;
  
  if (!account || !date || value === undefined) {
    throw new Error('Missing delete parameters: account, date, and value required.');
  }

  const sh = SpreadsheetApp.getActive().getSheetByName(SHEET_VALUES);
  if (!sh) throw new Error('Missing sheet: ' + SHEET_VALUES);
  
  const range = sh.getDataRange();
  const values = range.getValues();
  const headers = values[0];
  
  const iDate = headers.indexOf('Date');
  const iAcct = headers.indexOf('Account');
  const iVal = headers.indexOf('Value');

  if (iDate === -1 || iAcct === -1 || iVal === -1) {
    throw new Error('Values sheet missing required columns: Date, Account, Value');
  }
  
  const targetDateStr = date; 
  const targetVal = Number(value);
  
  let rowToDelete = -1;
  
  for (let i = values.length - 1; i >= 1; i--) {
    const row = values[i];
    
    // Use toISODate for comparison, as sheet dates can have times
    const rowDateStr = toISODate(new Date(row[iDate])); 
    const rowAcct = String(row[iAcct]);
    const rowVal = Number(row[iVal]);
    
    // We only check YYYY-MM-DD, account, and value.
    // This means deleting an entry from "Today" might delete the
    // *first* match it finds, not necessarily the one at HH:MM.
    // This is a limitation of passing only the date.
    // For v1f, this is acceptable.
    if (rowAcct === account && rowDateStr === targetDateStr && rowVal === targetVal) {
      rowToDelete = i + 1;
      break;
    }
  }
  
  if (rowToDelete > -1) {
    sh.deleteRow(rowToDelete);
    return { ok: true, deleted: { account, date, value } };
  } else {
    return { ok: false, error: 'Entry not found. It may have been modified or deleted.' };
  }
}


/** * Gets the latest value for a set of accounts.
 * @param {Set<string>} nameSet - A Set of account names.
 * @returns {Map<string, number|object>} Map of AccountName -> LastValue
 * Also stores AccountName:info -> {date: Date, dateStr: string}
 */
function getLatestMap(nameSet) {
  const map = new Map(Array.from(nameSet, n => [n, NaN]));
  const sh = SpreadsheetApp.getActive().getSheetByName(SHEET_VALUES);
  if (!sh) return map;
  const range = sh.getDataRange();
  if (range.getNumRows() < 2) return map;
  
  const values = range.getValues();
  const headers = values[0];
  const iDate = headers.indexOf('Date');
  const iAcct = headers.indexOf('Account');
  const iVal = headers.indexOf('Value');

  if (iDate === -1 || iAcct === -1 || iVal === -1) {
    throw new Error('Values sheet missing required columns: Date, Account, Value');
  }

  const dateMap = new Map();

  for (let r = 1; r < values.length; r++) {
    const acct = String(values[r][iAcct]);
    if (!nameSet.has(acct)) continue;
    
    const d = new Date(values[r][iDate]);
    if (d.getFullYear() < 1970) continue;
    
    const v = Number(values[r][iVal]);
    if (!isFinite(v)) continue;
    
    const curDate = dateMap.get(acct);
    if (!curDate || d >= curDate) {
      map.set(acct, v);
      dateMap.set(acct, d);
      // NEW: Store date info for copy-forward logic
      map.set(acct + ':info', { date: d, dateStr: toISODate(d) });
    }
  }
  return map;
}
